#![allow(unknown_lints)]
#![allow(warnings)]
#![allow(clippy)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const PBSE_DONOTUSE1: u32 = 15360;
pub const PBSE_DONOTUSE2: u32 = 15616;
pub const PBSE_DONOTUSE3: u32 = 15872;
pub const PBSE_DONOTUSE4: u32 = 16128;
pub const PBSE_DONOTUSE5: u32 = 16384;
pub const PBSE_: u32 = 15000;
pub const PBSE_NONE: u32 = 0;
pub const PBSE_UNKJOBID: u32 = 15001;
pub const PBSE_NOATTR: u32 = 15002;
pub const PBSE_ATTRRO: u32 = 15003;
pub const PBSE_IVALREQ: u32 = 15004;
pub const PBSE_UNKREQ: u32 = 15005;
pub const PBSE_TOOMANY: u32 = 15006;
pub const PBSE_PERM: u32 = 15007;
pub const PBSE_BADHOST: u32 = 15008;
pub const PBSE_JOBEXIST: u32 = 15009;
pub const PBSE_SYSTEM: u32 = 15010;
pub const PBSE_INTERNAL: u32 = 15011;
pub const PBSE_REGROUTE: u32 = 15012;
pub const PBSE_UNKSIG: u32 = 15013;
pub const PBSE_BADATVAL: u32 = 15014;
pub const PBSE_MODATRRUN: u32 = 15015;
pub const PBSE_BADSTATE: u32 = 15016;
pub const PBSE_UNKQUE: u32 = 15018;
pub const PBSE_BADCRED: u32 = 15019;
pub const PBSE_EXPIRED: u32 = 15020;
pub const PBSE_QUNOENB: u32 = 15021;
pub const PBSE_QACESS: u32 = 15022;
pub const PBSE_BADUSER: u32 = 15023;
pub const PBSE_HOPCOUNT: u32 = 15024;
pub const PBSE_QUEEXIST: u32 = 15025;
pub const PBSE_ATTRTYPE: u32 = 15026;
pub const PBSE_OBJBUSY: u32 = 15027;
pub const PBSE_QUENBIG: u32 = 15028;
pub const PBSE_NOSUP: u32 = 15029;
pub const PBSE_QUENOEN: u32 = 15030;
pub const PBSE_PROTOCOL: u32 = 15031;
pub const PBSE_BADATLST: u32 = 15032;
pub const PBSE_NOCONNECTS: u32 = 15033;
pub const PBSE_NOSERVER: u32 = 15034;
pub const PBSE_UNKRESC: u32 = 15035;
pub const PBSE_EXCQRESC: u32 = 15036;
pub const PBSE_QUENODFLT: u32 = 15037;
pub const PBSE_NORERUN: u32 = 15038;
pub const PBSE_ROUTEREJ: u32 = 15039;
pub const PBSE_ROUTEEXPD: u32 = 15040;
pub const PBSE_MOMREJECT: u32 = 15041;
pub const PBSE_BADSCRIPT: u32 = 15042;
pub const PBSE_STAGEIN: u32 = 15043;
pub const PBSE_RESCUNAV: u32 = 15044;
pub const PBSE_BADGRP: u32 = 15045;
pub const PBSE_MAXQUED: u32 = 15046;
pub const PBSE_CKPBSY: u32 = 15047;
pub const PBSE_EXLIMIT: u32 = 15048;
pub const PBSE_BADACCT: u32 = 15049;
pub const PBSE_ALRDYEXIT: u32 = 15050;
pub const PBSE_NOCOPYFILE: u32 = 15051;
pub const PBSE_CLEANEDOUT: u32 = 15052;
pub const PBSE_NOSYNCMSTR: u32 = 15053;
pub const PBSE_BADDEPEND: u32 = 15054;
pub const PBSE_DUPLIST: u32 = 15055;
pub const PBSE_DISPROTO: u32 = 15056;
pub const PBSE_EXECTHERE: u32 = 15057;
pub const PBSE_SISREJECT: u32 = 15058;
pub const PBSE_SISCOMM: u32 = 15059;
pub const PBSE_SVRDOWN: u32 = 15060;
pub const PBSE_CKPSHORT: u32 = 15061;
pub const PBSE_UNKNODE: u32 = 15062;
pub const PBSE_UNKNODEATR: u32 = 15063;
pub const PBSE_NONODES: u32 = 15064;
pub const PBSE_NODENBIG: u32 = 15065;
pub const PBSE_NODEEXIST: u32 = 15066;
pub const PBSE_BADNDATVAL: u32 = 15067;
pub const PBSE_MUTUALEX: u32 = 15068;
pub const PBSE_GMODERR: u32 = 15069;
pub const PBSE_NORELYMOM: u32 = 15070;
pub const PBSE_NOTSNODE: u32 = 15071;
pub const PBSE_RESV_NO_WALLTIME: u32 = 15075;
pub const PBSE_JOBNOTRESV: u32 = 15076;
pub const PBSE_TOOLATE: u32 = 15077;
pub const PBSE_IRESVE: u32 = 15078;
pub const PBSE_UNKRESVTYPE: u32 = 15079;
pub const PBSE_RESVEXIST: u32 = 15080;
pub const PBSE_resvFail: u32 = 15081;
pub const PBSE_genBatchReq: u32 = 15082;
pub const PBSE_mgrBatchReq: u32 = 15083;
pub const PBSE_UNKRESVID: u32 = 15084;
pub const PBSE_delProgress: u32 = 15085;
pub const PBSE_BADTSPEC: u32 = 15086;
pub const PBSE_RESVMSG: u32 = 15087;
pub const PBSE_NOTRESV: u32 = 15088;
pub const PBSE_BADNODESPEC: u32 = 15089;
pub const PBSE_LICENSECPU: u32 = 15090;
pub const PBSE_LICENSEINV: u32 = 15091;
pub const PBSE_RESVAUTH_H: u32 = 15092;
pub const PBSE_RESVAUTH_G: u32 = 15093;
pub const PBSE_RESVAUTH_U: u32 = 15094;
pub const PBSE_R_UID: u32 = 15095;
pub const PBSE_R_GID: u32 = 15096;
pub const PBSE_IBMSPSWITCH: u32 = 15097;
pub const PBSE_LICENSEUNAV: u32 = 15098;
pub const PBSE_NOSCHEDULER: u32 = 15099;
pub const PBSE_RESCNOTSTR: u32 = 15100;
pub const PBSE_MaxArraySize: u32 = 15107;
pub const PBSE_INVALSELECTRESC: u32 = 15108;
pub const PBSE_INVALJOBRESC: u32 = 15109;
pub const PBSE_INVALNODEPLACE: u32 = 15110;
pub const PBSE_PLACENOSELECT: u32 = 15111;
pub const PBSE_INDIRECTHOP: u32 = 15112;
pub const PBSE_INDIRECTBT: u32 = 15113;
pub const PBSE_NGBLUEGENE: u32 = 15114;
pub const PBSE_NODESTALE: u32 = 15115;
pub const PBSE_DUPRESC: u32 = 15116;
pub const PBSE_CONNFULL: u32 = 15117;
pub const PBSE_LICENSE_MIN_BADVAL: u32 = 15118;
pub const PBSE_LICENSE_MAX_BADVAL: u32 = 15119;
pub const PBSE_LICENSE_LINGER_BADVAL: u32 = 15120;
pub const PBSE_LICENSE_SERVER_DOWN: u32 = 15121;
pub const PBSE_LICENSE_BAD_ACTION: u32 = 15122;
pub const PBSE_BAD_FORMULA: u32 = 15123;
pub const PBSE_BAD_FORMULA_KW: u32 = 15124;
pub const PBSE_BAD_FORMULA_TYPE: u32 = 15125;
pub const PBSE_BAD_RRULE_YEARLY: u32 = 15126;
pub const PBSE_BAD_RRULE_MONTHLY: u32 = 15127;
pub const PBSE_BAD_RRULE_WEEKLY: u32 = 15128;
pub const PBSE_BAD_RRULE_DAILY: u32 = 15129;
pub const PBSE_BAD_RRULE_HOURLY: u32 = 15130;
pub const PBSE_BAD_RRULE_MINUTELY: u32 = 15131;
pub const PBSE_BAD_RRULE_SECONDLY: u32 = 15132;
pub const PBSE_BAD_RRULE_SYNTAX: u32 = 15133;
pub const PBSE_BAD_RRULE_SYNTAX2: u32 = 15134;
pub const PBSE_BAD_ICAL_TZ: u32 = 15135;
pub const PBSE_HOOKERROR: u32 = 15136;
pub const PBSE_NEEDQUET: u32 = 15137;
pub const PBSE_ETEERROR: u32 = 15138;
pub const PBSE_HISTJOBID: u32 = 15139;
pub const PBSE_JOBHISTNOTSET: u32 = 15140;
pub const PBSE_MIXENTLIMS: u32 = 15141;
pub const PBSE_ENTLIMCT: u32 = 15142;
pub const PBSE_ENTLIMRESC: u32 = 15143;
pub const PBSE_ATVALERANGE: u32 = 15144;
pub const PBSE_PROV_HEADERROR: u32 = 15145;
pub const PBSE_NODEPROV_NOACTION: u32 = 15146;
pub const PBSE_NODEPROV: u32 = 15147;
pub const PBSE_NODEPROV_NODEL: u32 = 15148;
pub const PBSE_NODE_BAD_CURRENT_AOE: u32 = 15149;
pub const PBSE_NOLOOPBACKIF: u32 = 15153;
pub const PBSE_IVAL_AOECHUNK: u32 = 15155;
pub const PBSE_JOBINRESV_CONFLICT: u32 = 15156;
pub const PBSE_NORUNALTEREDJOB: u32 = 15157;
pub const PBSE_HISTJOBDELETED: u32 = 15158;
pub const PBSE_NOHISTARRAYSUBJOB: u32 = 15159;
pub const PBSE_FORCE_QSUB_UPDATE: u32 = 15160;
pub const PBSE_SAVE_ERR: u32 = 15161;
pub const PBSE_MAX_NO_MINWT: u32 = 15162;
pub const PBSE_MIN_GT_MAXWT: u32 = 15163;
pub const PBSE_NOSTF_RESV: u32 = 15164;
pub const PBSE_NOSTF_JOBARRAY: u32 = 15165;
pub const PBSE_NOLIMIT_RESOURCE: u32 = 15166;
pub const PBSE_MOM_INCOMPLETE_HOOK: u32 = 15167;
pub const PBSE_MOM_REJECT_ROOT_SCRIPTS: u32 = 15168;
pub const PBSE_HOOK_REJECT: u32 = 15169;
pub const PBSE_HOOK_REJECT_RERUNJOB: u32 = 15170;
pub const PBSE_HOOK_REJECT_DELETEJOB: u32 = 15171;
pub const PBSE_IVAL_OBJ_NAME: u32 = 15172;
pub const PBSE_JOBNBIG: u32 = 15173;
pub const PBSE_RESCBUSY: u32 = 15174;
pub const PBSE_JOBSCRIPTMAXSIZE: u32 = 15175;
pub const PBSE_BADJOBSCRIPTMAXSIZE: u32 = 15176;
pub const PBSE_WRONG_RESUME: u32 = 15177;
pub const PBSE_RESV_NOT_EMPTY: u32 = 15178;
pub const PBSE_STDG_RESV_OCCR_CONFLICT: u32 = 15179;
pub const PBSE_SOFTWT_STF: u32 = 15180;
pub const PBSE_RESV_FROM_RESVJOB: u32 = 15181;
pub const PBSE_RESV_FROM_ARRJOB: u32 = 15182;
pub const PBSE_SELECT_NOT_SUBSET: u32 = 15183;
pub const PBSE_RMUNKNOWN: u32 = 15201;
pub const PBSE_RMBADPARAM: u32 = 15202;
pub const PBSE_RMNOPARAM: u32 = 15203;
pub const PBSE_RMEXIST: u32 = 15204;
pub const PBSE_RMSYSTEM: u32 = 15205;
pub const PBSE_RMPART: u32 = 15206;
pub const RM_ERR_UNKNOWN: u32 = 15201;
pub const RM_ERR_BADPARAM: u32 = 15202;
pub const RM_ERR_NOPARAM: u32 = 15203;
pub const RM_ERR_EXIST: u32 = 15204;
pub const RM_ERR_SYSTEM: u32 = 15205;
pub const PBSE_TRYAGAIN: u32 = 15208;
pub const PBSE_ALPSRELERR: u32 = 15209;
pub const PBSE_JOB_MOVED: u32 = 15210;
pub const PBSE_SCHEDEXIST: u32 = 15211;
pub const PBSE_SCHED_NAME_BIG: u32 = 15212;
pub const PBSE_UNKSCHED: u32 = 15213;
pub const PBSE_SCHED_NO_DEL: u32 = 15214;
pub const PBSE_SCHED_PRIV_EXIST: u32 = 15215;
pub const PBSE_SCHED_LOG_EXIST: u32 = 15216;
pub const PBSE_ROUTE_QUE_NO_PARTITION: u32 = 15217;
pub const PBSE_CANNOT_SET_ROUTE_QUE: u32 = 15218;
pub const PBSE_QUE_NOT_IN_PARTITION: u32 = 15219;
pub const PBSE_PARTITION_NOT_IN_QUE: u32 = 15220;
pub const PBSE_INVALID_PARTITION_QUE: u32 = 15221;
pub const PBSE_ALPS_SWITCH_ERR: u32 = 15222;
pub const PBSE_SCHED_OP_NOT_PERMITTED: u32 = 15223;
pub const PBSE_SCHED_PARTITION_ALREADY_EXISTS: u32 = 15224;
pub const PBSE_INVALID_MAX_JOB_SEQUENCE_ID: u32 = 15225;
pub const PBSE_SVR_SCHED_JSF_INCOMPAT: u32 = 15226;
pub const PBSE_NODE_BUSY: u32 = 15227;
pub const PBSE_DEFAULT_PARTITION: u32 = 15228;
pub const PBSE_HISTDEPEND: u32 = 15229;
pub const PBSE_NOTARRAY_ATTR: u32 = 15231;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const __USE_ANSI: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _SVID_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_SVID: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201103;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 17;
pub const __GLIBC_HAVE_LONG_LONG: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const TYPE_ATTR_READONLY: u32 = 1;
pub const TYPE_ATTR_PUBLIC: u32 = 2;
pub const TYPE_ATTR_INVISIBLE: u32 = 4;
pub const TYPE_ATTR_ALL: u32 = 7;
pub const ATTR_a: &[u8; 15usize] = b"Execution_Time\0";
pub const ATTR_c: &[u8; 11usize] = b"Checkpoint\0";
pub const ATTR_e: &[u8; 11usize] = b"Error_Path\0";
pub const ATTR_g: &[u8; 11usize] = b"group_list\0";
pub const ATTR_h: &[u8; 11usize] = b"Hold_Types\0";
pub const ATTR_j: &[u8; 10usize] = b"Join_Path\0";
pub const ATTR_J: &[u8; 24usize] = b"array_indices_submitted\0";
pub const ATTR_k: &[u8; 11usize] = b"Keep_Files\0";
pub const ATTR_l: &[u8; 14usize] = b"Resource_List\0";
pub const ATTR_l_orig: &[u8; 19usize] = b"Resource_List_orig\0";
pub const ATTR_l_acct: &[u8; 19usize] = b"Resource_List_acct\0";
pub const ATTR_m: &[u8; 12usize] = b"Mail_Points\0";
pub const ATTR_o: &[u8; 12usize] = b"Output_Path\0";
pub const ATTR_p: &[u8; 9usize] = b"Priority\0";
pub const ATTR_q: &[u8; 12usize] = b"destination\0";
pub const ATTR_R: &[u8; 13usize] = b"Remove_Files\0";
pub const ATTR_r: &[u8; 10usize] = b"Rerunable\0";
pub const ATTR_u: &[u8; 10usize] = b"User_List\0";
pub const ATTR_v: &[u8; 14usize] = b"Variable_List\0";
pub const ATTR_A: &[u8; 13usize] = b"Account_Name\0";
pub const ATTR_M: &[u8; 11usize] = b"Mail_Users\0";
pub const ATTR_N: &[u8; 9usize] = b"Job_Name\0";
pub const ATTR_S: &[u8; 16usize] = b"Shell_Path_List\0";
pub const ATTR_array_indices_submitted: &[u8; 24usize] = b"array_indices_submitted\0";
pub const ATTR_depend: &[u8; 7usize] = b"depend\0";
pub const ATTR_inter: &[u8; 12usize] = b"interactive\0";
pub const ATTR_sandbox: &[u8; 8usize] = b"sandbox\0";
pub const ATTR_stagein: &[u8; 8usize] = b"stagein\0";
pub const ATTR_stageout: &[u8; 9usize] = b"stageout\0";
pub const ATTR_resvTag: &[u8; 12usize] = b"reserve_Tag\0";
pub const ATTR_resv_start: &[u8; 14usize] = b"reserve_start\0";
pub const ATTR_resv_end: &[u8; 12usize] = b"reserve_end\0";
pub const ATTR_resv_duration: &[u8; 17usize] = b"reserve_duration\0";
pub const ATTR_resv_state: &[u8; 14usize] = b"reserve_state\0";
pub const ATTR_resv_substate: &[u8; 17usize] = b"reserve_substate\0";
pub const ATTR_resv_job: &[u8; 12usize] = b"reserve_job\0";
pub const ATTR_auth_u: &[u8; 17usize] = b"Authorized_Users\0";
pub const ATTR_auth_g: &[u8; 18usize] = b"Authorized_Groups\0";
pub const ATTR_auth_h: &[u8; 17usize] = b"Authorized_Hosts\0";
pub const ATTR_cred: &[u8; 5usize] = b"cred\0";
pub const ATTR_nodemux: &[u8; 17usize] = b"no_stdio_sockets\0";
pub const ATTR_umask: &[u8; 6usize] = b"umask\0";
pub const ATTR_block: &[u8; 6usize] = b"block\0";
pub const ATTR_convert: &[u8; 6usize] = b"qmove\0";
pub const ATTR_DefaultChunk: &[u8; 14usize] = b"default_chunk\0";
pub const ATTR_X11_cookie: &[u8; 19usize] = b"forward_x11_cookie\0";
pub const ATTR_X11_port: &[u8; 17usize] = b"forward_x11_port\0";
pub const ATTR_GUI: &[u8; 4usize] = b"gui\0";
pub const ATTR_max_run_subjobs: &[u8; 16usize] = b"max_run_subjobs\0";
pub const ATTR_resv_standing: &[u8; 17usize] = b"reserve_standing\0";
pub const ATTR_resv_count: &[u8; 14usize] = b"reserve_count\0";
pub const ATTR_resv_idx: &[u8; 14usize] = b"reserve_index\0";
pub const ATTR_resv_rrule: &[u8; 14usize] = b"reserve_rrule\0";
pub const ATTR_resv_execvnodes: &[u8; 19usize] = b"reserve_execvnodes\0";
pub const ATTR_resv_timezone: &[u8; 17usize] = b"reserve_timezone\0";
pub const ATTR_ctime: &[u8; 6usize] = b"ctime\0";
pub const ATTR_estimated: &[u8; 10usize] = b"estimated\0";
pub const ATTR_exechost: &[u8; 10usize] = b"exec_host\0";
pub const ATTR_exechost_acct: &[u8; 15usize] = b"exec_host_acct\0";
pub const ATTR_exechost_orig: &[u8; 15usize] = b"exec_host_orig\0";
pub const ATTR_exechost2: &[u8; 11usize] = b"exec_host2\0";
pub const ATTR_execvnode: &[u8; 11usize] = b"exec_vnode\0";
pub const ATTR_execvnode_acct: &[u8; 16usize] = b"exec_vnode_acct\0";
pub const ATTR_execvnode_deallocated: &[u8; 23usize] = b"exec_vnode_deallocated\0";
pub const ATTR_execvnode_orig: &[u8; 16usize] = b"exec_vnode_orig\0";
pub const ATTR_resv_nodes: &[u8; 11usize] = b"resv_nodes\0";
pub const ATTR_mtime: &[u8; 6usize] = b"mtime\0";
pub const ATTR_qtime: &[u8; 6usize] = b"qtime\0";
pub const ATTR_session: &[u8; 11usize] = b"session_id\0";
pub const ATTR_jobdir: &[u8; 7usize] = b"jobdir\0";
pub const ATTR_euser: &[u8; 6usize] = b"euser\0";
pub const ATTR_egroup: &[u8; 7usize] = b"egroup\0";
pub const ATTR_project: &[u8; 8usize] = b"project\0";
pub const ATTR_hashname: &[u8; 9usize] = b"hashname\0";
pub const ATTR_hopcount: &[u8; 10usize] = b"hop_count\0";
pub const ATTR_security: &[u8; 9usize] = b"security\0";
pub const ATTR_sched_hint: &[u8; 11usize] = b"sched_hint\0";
pub const ATTR_SchedSelect: &[u8; 12usize] = b"schedselect\0";
pub const ATTR_SchedSelect_orig: &[u8; 17usize] = b"schedselect_orig\0";
pub const ATTR_substate: &[u8; 9usize] = b"substate\0";
pub const ATTR_name: &[u8; 9usize] = b"Job_Name\0";
pub const ATTR_owner: &[u8; 10usize] = b"Job_Owner\0";
pub const ATTR_used: &[u8; 15usize] = b"resources_used\0";
pub const ATTR_used_acct: &[u8; 20usize] = b"resources_used_acct\0";
pub const ATTR_used_update: &[u8; 22usize] = b"resources_used_update\0";
pub const ATTR_relnodes_on_stageout: &[u8; 26usize] = b"release_nodes_on_stageout\0";
pub const ATTR_tolerate_node_failures: &[u8; 23usize] = b"tolerate_node_failures\0";
pub const ATTR_released: &[u8; 19usize] = b"resources_released\0";
pub const ATTR_rel_list: &[u8; 23usize] = b"resource_released_list\0";
pub const ATTR_state: &[u8; 10usize] = b"job_state\0";
pub const ATTR_queue: &[u8; 6usize] = b"queue\0";
pub const ATTR_server: &[u8; 7usize] = b"server\0";
pub const ATTR_maxrun: &[u8; 12usize] = b"max_running\0";
pub const ATTR_max_run: &[u8; 8usize] = b"max_run\0";
pub const ATTR_max_run_res: &[u8; 12usize] = b"max_run_res\0";
pub const ATTR_max_run_soft: &[u8; 13usize] = b"max_run_soft\0";
pub const ATTR_max_run_res_soft: &[u8; 17usize] = b"max_run_res_soft\0";
pub const ATTR_total: &[u8; 11usize] = b"total_jobs\0";
pub const ATTR_comment: &[u8; 8usize] = b"comment\0";
pub const ATTR_cookie: &[u8; 7usize] = b"cookie\0";
pub const ATTR_qrank: &[u8; 11usize] = b"queue_rank\0";
pub const ATTR_altid: &[u8; 7usize] = b"alt_id\0";
pub const ATTR_altid2: &[u8; 8usize] = b"alt_id2\0";
pub const ATTR_acct_id: &[u8; 14usize] = b"accounting_id\0";
pub const ATTR_array: &[u8; 6usize] = b"array\0";
pub const ATTR_array_id: &[u8; 9usize] = b"array_id\0";
pub const ATTR_array_index: &[u8; 12usize] = b"array_index\0";
pub const ATTR_array_state_count: &[u8; 18usize] = b"array_state_count\0";
pub const ATTR_array_indices_remaining: &[u8; 24usize] = b"array_indices_remaining\0";
pub const ATTR_etime: &[u8; 6usize] = b"etime\0";
pub const ATTR_gridname: &[u8; 9usize] = b"gridname\0";
pub const ATTR_refresh: &[u8; 21usize] = b"last_context_refresh\0";
pub const ATTR_ReqCredEnable: &[u8; 20usize] = b"require_cred_enable\0";
pub const ATTR_ReqCred: &[u8; 13usize] = b"require_cred\0";
pub const ATTR_runcount: &[u8; 10usize] = b"run_count\0";
pub const ATTR_run_version: &[u8; 12usize] = b"run_version\0";
pub const ATTR_stime: &[u8; 6usize] = b"stime\0";
pub const ATTR_pset: &[u8; 5usize] = b"pset\0";
pub const ATTR_executable: &[u8; 11usize] = b"executable\0";
pub const ATTR_Arglist: &[u8; 14usize] = b"argument_list\0";
pub const ATTR_version: &[u8; 12usize] = b"pbs_version\0";
pub const ATTR_eligible_time: &[u8; 14usize] = b"eligible_time\0";
pub const ATTR_accrue_type: &[u8; 12usize] = b"accrue_type\0";
pub const ATTR_sample_starttime: &[u8; 17usize] = b"sample_starttime\0";
pub const ATTR_job_kill_delay: &[u8; 15usize] = b"job_kill_delay\0";
pub const ATTR_topjob_ineligible: &[u8; 18usize] = b"topjob_ineligible\0";
pub const ATTR_submit_host: &[u8; 12usize] = b"Submit_Host\0";
pub const ATTR_cred_id: &[u8; 14usize] = b"credential_id\0";
pub const ATTR_security_context: &[u8; 17usize] = b"security_context\0";
pub const ATTR_cred_validity: &[u8; 20usize] = b"credential_validity\0";
pub const ATTR_history_timestamp: &[u8; 18usize] = b"history_timestamp\0";
pub const ATTR_create_resv_from_job: &[u8; 21usize] = b"create_resv_from_job\0";
pub const ATTR_stageout_status: &[u8; 16usize] = b"Stageout_status\0";
pub const ATTR_exit_status: &[u8; 12usize] = b"Exit_status\0";
pub const ATTR_submit_arguments: &[u8; 17usize] = b"Submit_arguments\0";
pub const ATTR_resv_name: &[u8; 13usize] = b"Reserve_Name\0";
pub const ATTR_resv_owner: &[u8; 14usize] = b"Reserve_Owner\0";
pub const ATTR_resv_type: &[u8; 13usize] = b"reserve_type\0";
pub const ATTR_resv_Tag: &[u8; 16usize] = b"reservation_Tag\0";
pub const ATTR_resv_ID: &[u8; 11usize] = b"reserve_ID\0";
pub const ATTR_resv_retry: &[u8; 14usize] = b"reserve_retry\0";
pub const ATTR_del_idle_time: &[u8; 17usize] = b"delete_idle_time\0";
pub const ATTR_aclgren: &[u8; 17usize] = b"acl_group_enable\0";
pub const ATTR_aclgroup: &[u8; 11usize] = b"acl_groups\0";
pub const ATTR_aclhten: &[u8; 16usize] = b"acl_host_enable\0";
pub const ATTR_aclhost: &[u8; 10usize] = b"acl_hosts\0";
pub const ATTR_aclhostmomsen: &[u8; 21usize] = b"acl_host_moms_enable\0";
pub const ATTR_acluren: &[u8; 16usize] = b"acl_user_enable\0";
pub const ATTR_acluser: &[u8; 10usize] = b"acl_users\0";
pub const ATTR_altrouter: &[u8; 11usize] = b"alt_router\0";
pub const ATTR_chkptmin: &[u8; 15usize] = b"checkpoint_min\0";
pub const ATTR_enable: &[u8; 8usize] = b"enabled\0";
pub const ATTR_fromroute: &[u8; 16usize] = b"from_route_only\0";
pub const ATTR_HasNodes: &[u8; 9usize] = b"hasnodes\0";
pub const ATTR_killdelay: &[u8; 11usize] = b"kill_delay\0";
pub const ATTR_maxgrprun: &[u8; 14usize] = b"max_group_run\0";
pub const ATTR_maxgrprunsoft: &[u8; 19usize] = b"max_group_run_soft\0";
pub const ATTR_maxque: &[u8; 13usize] = b"max_queuable\0";
pub const ATTR_max_queued: &[u8; 11usize] = b"max_queued\0";
pub const ATTR_max_queued_res: &[u8; 15usize] = b"max_queued_res\0";
pub const ATTR_queued_jobs_threshold: &[u8; 22usize] = b"queued_jobs_threshold\0";
pub const ATTR_queued_jobs_threshold_res: &[u8; 26usize] = b"queued_jobs_threshold_res\0";
pub const ATTR_maxuserrun: &[u8; 13usize] = b"max_user_run\0";
pub const ATTR_maxuserrunsoft: &[u8; 18usize] = b"max_user_run_soft\0";
pub const ATTR_qtype: &[u8; 11usize] = b"queue_type\0";
pub const ATTR_rescassn: &[u8; 19usize] = b"resources_assigned\0";
pub const ATTR_rescdflt: &[u8; 18usize] = b"resources_default\0";
pub const ATTR_rescmax: &[u8; 14usize] = b"resources_max\0";
pub const ATTR_rescmin: &[u8; 14usize] = b"resources_min\0";
pub const ATTR_rndzretry: &[u8; 17usize] = b"rendezvous_retry\0";
pub const ATTR_routedest: &[u8; 19usize] = b"route_destinations\0";
pub const ATTR_routeheld: &[u8; 16usize] = b"route_held_jobs\0";
pub const ATTR_routewait: &[u8; 19usize] = b"route_waiting_jobs\0";
pub const ATTR_routeretry: &[u8; 17usize] = b"route_retry_time\0";
pub const ATTR_routelife: &[u8; 15usize] = b"route_lifetime\0";
pub const ATTR_rsvexpdt: &[u8; 18usize] = b"reserved_expedite\0";
pub const ATTR_rsvsync: &[u8; 14usize] = b"reserved_sync\0";
pub const ATTR_start: &[u8; 8usize] = b"started\0";
pub const ATTR_count: &[u8; 12usize] = b"state_count\0";
pub const ATTR_number: &[u8; 12usize] = b"number_jobs\0";
pub const ATTR_jobscript_max_size: &[u8; 19usize] = b"jobscript_max_size\0";
pub const ATTR_SvrHost: &[u8; 12usize] = b"server_host\0";
pub const ATTR_aclroot: &[u8; 10usize] = b"acl_roots\0";
pub const ATTR_managers: &[u8; 9usize] = b"managers\0";
pub const ATTR_dfltque: &[u8; 14usize] = b"default_queue\0";
pub const ATTR_defnode: &[u8; 13usize] = b"default_node\0";
pub const ATTR_locsvrs: &[u8; 17usize] = b"location_servers\0";
pub const ATTR_logevents: &[u8; 11usize] = b"log_events\0";
pub const ATTR_logfile: &[u8; 9usize] = b"log_file\0";
pub const ATTR_mailfrom: &[u8; 10usize] = b"mail_from\0";
pub const ATTR_nodepack: &[u8; 10usize] = b"node_pack\0";
pub const ATTR_nodefailrq: &[u8; 18usize] = b"node_fail_requeue\0";
pub const ATTR_operators: &[u8; 10usize] = b"operators\0";
pub const ATTR_queryother: &[u8; 17usize] = b"query_other_jobs\0";
pub const ATTR_resccost: &[u8; 15usize] = b"resources_cost\0";
pub const ATTR_rescavail: &[u8; 20usize] = b"resources_available\0";
pub const ATTR_maxuserres: &[u8; 13usize] = b"max_user_res\0";
pub const ATTR_maxuserressoft: &[u8; 18usize] = b"max_user_res_soft\0";
pub const ATTR_maxgroupres: &[u8; 14usize] = b"max_group_res\0";
pub const ATTR_maxgroupressoft: &[u8; 19usize] = b"max_group_res_soft\0";
pub const ATTR_maxarraysize: &[u8; 15usize] = b"max_array_size\0";
pub const ATTR_PNames: &[u8; 7usize] = b"pnames\0";
pub const ATTR_schediteration: &[u8; 20usize] = b"scheduler_iteration\0";
pub const ATTR_scheduling: &[u8; 11usize] = b"scheduling\0";
pub const ATTR_status: &[u8; 13usize] = b"server_state\0";
pub const ATTR_syscost: &[u8; 12usize] = b"system_cost\0";
pub const ATTR_FlatUID: &[u8; 8usize] = b"flatuid\0";
pub const ATTR_ResvEnable: &[u8; 12usize] = b"resv_enable\0";
pub const ATTR_aclResvgren: &[u8; 22usize] = b"acl_resv_group_enable\0";
pub const ATTR_aclResvgroup: &[u8; 16usize] = b"acl_resv_groups\0";
pub const ATTR_aclResvhten: &[u8; 21usize] = b"acl_resv_host_enable\0";
pub const ATTR_aclResvhost: &[u8; 15usize] = b"acl_resv_hosts\0";
pub const ATTR_aclResvuren: &[u8; 21usize] = b"acl_resv_user_enable\0";
pub const ATTR_aclResvuser: &[u8; 15usize] = b"acl_resv_users\0";
pub const ATTR_NodeGroupEnable: &[u8; 18usize] = b"node_group_enable\0";
pub const ATTR_NodeGroupKey: &[u8; 15usize] = b"node_group_key\0";
pub const ATTR_dfltqdelargs: &[u8; 23usize] = b"default_qdel_arguments\0";
pub const ATTR_dfltqsubargs: &[u8; 23usize] = b"default_qsub_arguments\0";
pub const ATTR_rpp_retry: &[u8; 10usize] = b"rpp_retry\0";
pub const ATTR_rpp_highwater: &[u8; 14usize] = b"rpp_highwater\0";
pub const ATTR_pbs_license_info: &[u8; 17usize] = b"pbs_license_info\0";
pub const ATTR_license_min: &[u8; 16usize] = b"pbs_license_min\0";
pub const ATTR_license_max: &[u8; 16usize] = b"pbs_license_max\0";
pub const ATTR_license_linger: &[u8; 24usize] = b"pbs_license_linger_time\0";
pub const ATTR_license_count: &[u8; 14usize] = b"license_count\0";
pub const ATTR_job_sort_formula: &[u8; 17usize] = b"job_sort_formula\0";
pub const ATTR_EligibleTimeEnable: &[u8; 21usize] = b"eligible_time_enable\0";
pub const ATTR_resv_retry_time: &[u8; 19usize] = b"reserve_retry_time\0";
pub const ATTR_resv_retry_init: &[u8; 19usize] = b"reserve_retry_init\0";
pub const ATTR_JobHistoryEnable: &[u8; 19usize] = b"job_history_enable\0";
pub const ATTR_JobHistoryDuration: &[u8; 21usize] = b"job_history_duration\0";
pub const ATTR_max_concurrent_prov: &[u8; 25usize] = b"max_concurrent_provision\0";
pub const ATTR_resv_post_processing: &[u8; 26usize] = b"resv_post_processing_time\0";
pub const ATTR_backfill_depth: &[u8; 15usize] = b"backfill_depth\0";
pub const ATTR_job_requeue_timeout: &[u8; 20usize] = b"job_requeue_timeout\0";
pub const ATTR_show_hidden_attribs: &[u8; 20usize] = b"show_hidden_attribs\0";
pub const ATTR_python_restart_max_hooks: &[u8; 25usize] = b"python_restart_max_hooks\0";
pub const ATTR_python_restart_max_objects: &[u8; 27usize] = b"python_restart_max_objects\0";
pub const ATTR_python_restart_min_interval: &[u8; 28usize] = b"python_restart_min_interval\0";
pub const ATTR_power_provisioning: &[u8; 19usize] = b"power_provisioning\0";
pub const ATTR_sync_mom_hookfiles_timeout: &[u8; 27usize] = b"sync_mom_hookfiles_timeout\0";
pub const ATTR_max_job_sequence_id: &[u8; 20usize] = b"max_job_sequence_id\0";
pub const ATTR_acl_krb_realm_enable: &[u8; 21usize] = b"acl_krb_realm_enable\0";
pub const ATTR_acl_krb_realms: &[u8; 15usize] = b"acl_krb_realms\0";
pub const ATTR_acl_krb_submit_realms: &[u8; 22usize] = b"acl_krb_submit_realms\0";
pub const ATTR_cred_renew_enable: &[u8; 18usize] = b"cred_renew_enable\0";
pub const ATTR_cred_renew_tool: &[u8; 16usize] = b"cred_renew_tool\0";
pub const ATTR_cred_renew_period: &[u8; 18usize] = b"cred_renew_period\0";
pub const ATTR_cred_renew_cache_period: &[u8; 24usize] = b"cred_renew_cache_period\0";
pub const ATTR_rpp_max_pkt_check: &[u8; 18usize] = b"rpp_max_pkt_check\0";
pub const ATTR_SchedHost: &[u8; 11usize] = b"sched_host\0";
pub const ATTR_sched_cycle_len: &[u8; 19usize] = b"sched_cycle_length\0";
pub const ATTR_do_not_span_psets: &[u8; 18usize] = b"do_not_span_psets\0";
pub const ATTR_only_explicit_psets: &[u8; 20usize] = b"only_explicit_psets\0";
pub const ATTR_sched_preempt_enforce_resumption: &[u8; 33usize] =
    b"sched_preempt_enforce_resumption\0";
pub const ATTR_preempt_targets_enable: &[u8; 23usize] = b"preempt_targets_enable\0";
pub const ATTR_job_sort_formula_threshold: &[u8; 27usize] = b"job_sort_formula_threshold\0";
pub const ATTR_throughput_mode: &[u8; 16usize] = b"throughput_mode\0";
pub const ATTR_opt_backfill_fuzzy: &[u8; 19usize] = b"opt_backfill_fuzzy\0";
pub const ATTR_sched_port: &[u8; 11usize] = b"sched_port\0";
pub const ATTR_partition: &[u8; 10usize] = b"partition\0";
pub const ATTR_sched_priv: &[u8; 11usize] = b"sched_priv\0";
pub const ATTR_sched_log: &[u8; 10usize] = b"sched_log\0";
pub const ATTR_sched_user: &[u8; 11usize] = b"sched_user\0";
pub const ATTR_sched_state: &[u8; 6usize] = b"state\0";
pub const ATTR_sched_preempt_queue_prio: &[u8; 19usize] = b"preempt_queue_prio\0";
pub const ATTR_sched_preempt_prio: &[u8; 13usize] = b"preempt_prio\0";
pub const ATTR_sched_preempt_order: &[u8; 14usize] = b"preempt_order\0";
pub const ATTR_sched_preempt_sort: &[u8; 13usize] = b"preempt_sort\0";
pub const ATTR_sched_server_dyn_res_alarm: &[u8; 21usize] = b"server_dyn_res_alarm\0";
pub const ATTR_NODE_Host: &[u8; 5usize] = b"Host\0";
pub const ATTR_NODE_Mom: &[u8; 4usize] = b"Mom\0";
pub const ATTR_NODE_Port: &[u8; 5usize] = b"Port\0";
pub const ATTR_NODE_state: &[u8; 6usize] = b"state\0";
pub const ATTR_NODE_ntype: &[u8; 6usize] = b"ntype\0";
pub const ATTR_NODE_jobs: &[u8; 5usize] = b"jobs\0";
pub const ATTR_NODE_resvs: &[u8; 5usize] = b"resv\0";
pub const ATTR_NODE_resv_enable: &[u8; 12usize] = b"resv_enable\0";
pub const ATTR_NODE_np: &[u8; 3usize] = b"np\0";
pub const ATTR_NODE_pcpus: &[u8; 6usize] = b"pcpus\0";
pub const ATTR_NODE_properties: &[u8; 11usize] = b"properties\0";
pub const ATTR_NODE_NoMultiNode: &[u8; 18usize] = b"no_multinode_jobs\0";
pub const ATTR_NODE_No_Tasks: &[u8; 9usize] = b"no_tasks\0";
pub const ATTR_NODE_Sharing: &[u8; 8usize] = b"sharing\0";
pub const ATTR_NODE_ProvisionEnable: &[u8; 17usize] = b"provision_enable\0";
pub const ATTR_NODE_current_aoe: &[u8; 12usize] = b"current_aoe\0";
pub const ATTR_NODE_in_multivnode_host: &[u8; 19usize] = b"in_multivnode_host\0";
pub const ATTR_NODE_License: &[u8; 8usize] = b"license\0";
pub const ATTR_NODE_LicenseInfo: &[u8; 13usize] = b"license_info\0";
pub const ATTR_NODE_TopologyInfo: &[u8; 14usize] = b"topology_info\0";
pub const ATTR_NODE_MaintJobs: &[u8; 17usize] = b"maintenance_jobs\0";
pub const ATTR_NODE_VnodePool: &[u8; 11usize] = b"vnode_pool\0";
pub const ATTR_NODE_current_eoe: &[u8; 12usize] = b"current_eoe\0";
pub const ATTR_NODE_power_provisioning: &[u8; 19usize] = b"power_provisioning\0";
pub const ATTR_NODE_poweroff_eligible: &[u8; 18usize] = b"poweroff_eligible\0";
pub const ATTR_NODE_last_state_change_time: &[u8; 23usize] = b"last_state_change_time\0";
pub const ATTR_NODE_last_used_time: &[u8; 15usize] = b"last_used_time\0";
pub const ND_RESC_LicSignature: &[u8; 14usize] = b"lic_signature\0";
pub const ATTR_RESC_TYPE: &[u8; 5usize] = b"type\0";
pub const ATTR_RESC_FLAG: &[u8; 5usize] = b"flag\0";
pub const CHECKPOINT_UNSPECIFIED: &[u8; 2usize] = b"u\0";
pub const NO_HOLD: &[u8; 2usize] = b"n\0";
pub const NO_JOIN: &[u8; 2usize] = b"n\0";
pub const NO_KEEP: &[u8; 2usize] = b"n\0";
pub const MAIL_AT_ABORT: &[u8; 2usize] = b"a\0";
pub const USER_HOLD: &[u8; 2usize] = b"u\0";
pub const OTHER_HOLD: &[u8; 2usize] = b"o\0";
pub const SYSTEM_HOLD: &[u8; 2usize] = b"s\0";
pub const BAD_PASSWORD_HOLD: &[u8; 2usize] = b"p\0";
pub const SITE_HOOK: &[u8; 5usize] = b"hook\0";
pub const PBS_HOOK: &[u8; 8usize] = b"pbshook\0";
pub const MSG_OUT: u32 = 1;
pub const MSG_ERR: u32 = 2;
pub const BLUEGENE: &[u8; 9usize] = b"bluegene\0";
pub const PBS_MAXHOSTNAME: u32 = 255;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const PBS_MAXSCHEDNAME: u32 = 15;
pub const PBS_MAXUSER: u32 = 256;
pub const PBS_MAXPWLEN: u32 = 256;
pub const PBS_MAXGRPN: u32 = 256;
pub const PBS_MAXQUEUENAME: u32 = 15;
pub const PBS_MAXJOBNAME: u32 = 230;
pub const PBS_MAXSERVERNAME: u32 = 255;
pub const PBS_MAXSEQNUM: u32 = 12;
pub const PBS_DFLT_MAX_JOB_SEQUENCE_ID: u32 = 9999999;
pub const PBS_MAXPORTNUM: u32 = 5;
pub const PBS_MAXSVRJOBID: u32 = 273;
pub const PBS_MAXSVRRESVID: u32 = 274;
pub const PBS_MAXQRESVNAME: u32 = 15;
pub const PBS_MAXCLTJOBID: u32 = 535;
pub const PBS_MAXDEST: u32 = 256;
pub const PBS_MAXROUTEDEST: u32 = 277;
pub const PBS_INTERACTIVE: u32 = 1;
pub const PBS_TERM_BUF_SZ: u32 = 80;
pub const PBS_TERM_CCA: u32 = 6;
pub const PBS_RESV_ID_CHAR: u8 = 82u8;
pub const PBS_STDNG_RESV_ID_CHAR: u8 = 83u8;
pub const PBS_MNTNC_RESV_ID_CHAR: u8 = 77u8;
pub const PBS_AUTH_KEY_LEN: u32 = 129;
pub const SHUT_IMMEDIATE: u32 = 0;
pub const SHUT_DELAY: u32 = 1;
pub const SHUT_QUICK: u32 = 2;
pub const FORCE: &[u8; 6usize] = b"force\0";
pub const NOMAIL: &[u8; 7usize] = b"nomail\0";
pub const SUPPRESS_EMAIL: &[u8; 15usize] = b"suppress_email\0";
pub const DELETEHISTORY: &[u8; 11usize] = b"deletehist\0";
#[doc = " the following structure is used to tie error number      */\n/* with text to be returned to a client, see svr_messages.c"]
#[repr(C)]
#[derive(Debug)]
pub struct pbs_err_to_txt {
    pub err_no: ::std::os::raw::c_int,
    pub err_txt: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pbs_err_to_txt() {
    const UNINIT: ::std::mem::MaybeUninit<pbs_err_to_txt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pbs_err_to_txt>(),
        16usize,
        concat!("Size of: ", stringify!(pbs_err_to_txt))
    );
    assert_eq!(
        ::std::mem::align_of::<pbs_err_to_txt>(),
        8usize,
        concat!("Alignment of ", stringify!(pbs_err_to_txt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_no) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbs_err_to_txt),
            "::",
            stringify!(err_no)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_txt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pbs_err_to_txt),
            "::",
            stringify!(err_txt)
        )
    );
}
extern "C" {
    pub fn pbse_to_txt(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __pbs_errno_location() -> *mut ::std::os::raw::c_int;
}
#[doc = " Convenience types."]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
#[doc = " These few don't really vary by system, they always correspond\nto one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[doc = " Define outside of namespace so the C++ is happy."]
pub type FILE = _IO_FILE;
#[doc = " Define outside of namespace so the C++ is happy."]
pub type __FILE = _IO_FILE;
#[doc = " Conversion state information."]
#[repr(C)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    #[doc = " Value so far."]
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[doc = " A streammarker remembers a position in a buffer."]
#[repr(C)]
#[derive(Debug)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    #[doc = " If _pos >= 0\nit points to _buf->Gbase()+_pos. FIXME comment */\n/* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment"]
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_marker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sbuf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
#[doc = " This is the structure from the libstdc++ codecvt class."]
pub type __codecvt_result = ::std::os::raw::c_uint;
#[doc = " Define outside of namespace so the C++ is happy."]
#[repr(C)]
#[derive(Debug)]
pub struct _IO_FILE {
    #[doc = " High-order word is _IO_MAGIC; rest is flags."]
    pub _flags: ::std::os::raw::c_int,
    #[doc = " Current read pointer"]
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    #[doc = " End of get area."]
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    #[doc = " Start of putback+get area."]
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    #[doc = " Start of put area."]
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    #[doc = " Current put pointer."]
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    #[doc = " End of put area."]
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    #[doc = " Start of reserve area."]
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    #[doc = " End of reserve area."]
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to start of non-current get area."]
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to first valid character of backup area"]
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    #[doc = " Pointer to end of non-current get area."]
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    #[doc = " This used to be _offset but it's too small."]
    pub _old_offset: __off_t,
    #[doc = " 1+column number of pbase(); 0 is unknown."]
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    #[doc = "  char* _save_gptr;  char* _save_egptr;"]
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    #[doc = " Make sure we don't get into trouble again."]
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
#[doc = " Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.\nReturn number of bytes read."]
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
#[doc = " Write N bytes pointed to by BUF to COOKIE.  Write all N bytes\nunless there is an error.  Return number of bytes written.  If\nthere is an error, return 0 and do not write anything.  If the file\nhas been opened for append (__mode.__append set), then set the file\npointer to the end of the file and then do the write; if not, just\nwrite at the current file pointer."]
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
#[doc = " Move COOKIE's file position to *POS bytes from the\nbeginning of the file (if W is SEEK_SET),\nthe current position (if W is SEEK_CUR),\nor the end of the file (if W is SEEK_END).\nSet *POS to the new file position.\nReturns zero if successful, nonzero if not."]
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Close COOKIE."]
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[doc = " Standard input stream."]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[doc = " Standard output stream."]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[doc = " Standard error output stream."]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    #[doc = " Remove file FILENAME."]
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rename file OLD to NEW."]
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Rename file OLD relative to OLDFD to NEW relative to NEWFD."]
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[doc = " Generate a temporary filename."]
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This is the reentrant variant of `tmpnam'.  The only difference is\nthat it does not allow S to be NULL."]
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Generate a unique temporary filename using up to five characters of PFX\nif it is not NULL.  The directory to put this file in is searched for\nas follows: First the environment variable \"TMPDIR\" is checked.\nIf it contains the name of a writable directory, that directory is used.\nIf not and if DIR is not NULL, that value is checked.  If that fails,\nP_tmpdir is tried and finally \"/tmp\".  The storage for the filename\nis allocated by `malloc'."]
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Close STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flush STREAM, or all streams if STREAM is NULL.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster versions when locking is not required.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a file and create a new stream for it.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Open a file, replacing an existing stream with it.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Create a new stream that refers to an existing system file descriptor."]
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    #[doc = " Create a new stream that refers to a memory buffer."]
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Open a stream that writes into a malloc'd buffer that is expanded as\nnecessary.  *BUFLOC and *SIZELOC are updated with the buffer's location\nand the number of characters written on fflush or fclose."]
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " If BUF is NULL, make STREAM unbuffered.\nElse make it use buffer BUF, of size BUFSIZ."]
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Make STREAM use buffering mode MODE.\nIf BUF is not NULL, use N bytes of it for buffering;\nelse allocate an internal buffer N bytes long."]
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If BUF is NULL, make STREAM unbuffered.\nElse make it use SIZE bytes of BUF for buffering."]
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    #[doc = " Make STREAM line-buffered."]
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Write formatted output to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S."]
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG."]
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Maximum chars of output to write in MAXLEN."]
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write formatted output to a file descriptor."]
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S."]
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a character from STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a character from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " These are defined in POSIX.1:1996.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster version when locking is not necessary.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a character to STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW.\n\nThese functions is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a character to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster version when locking is not necessary.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " These are defined in POSIX.1:1996.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a word (int) from STREAM."]
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a word (int) to STREAM."]
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a newline-terminated string of finite length from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read up to (and including) a DELIMITER from STREAM into *LINEPTR\n(and null-terminate it). *LINEPTR is a pointer returned from malloc (or\nNULL), pointing to *N characters of space.  It is realloc'd as\nnecessary.  Returns the number of characters read (not including the\nnull terminator), or -1 on error or EOF.\n\nThese functions are not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation they are cancellation points and\ntherefore not marked with __THROW."]
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    #[doc = " Like `getdelim', but reads up to a newline.\n\nThis function is not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation it is a cancellation point and\ntherefore not marked with __THROW."]
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    #[doc = " Write a string to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a string, followed by a newline, to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Push a character back onto the input buffer of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read chunks of generic data from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Write chunks of generic data to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Faster versions when locking is not necessary.\n\nThese functions are not part of POSIX and therefore no official\ncancellation point.  But due to similarity with an POSIX interface\nor due to the implementation they are cancellation points and\ntherefore not marked with __THROW."]
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[doc = " Seek to a certain position on STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current position of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Rewind to the beginning of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Seek to a certain position on STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current position of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    #[doc = " Get STREAM's position.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set STREAM's position.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear the error and EOF indicators for STREAM."]
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Return the EOF indicator for STREAM."]
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the error indicator for STREAM."]
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster versions when locking is not required."]
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print a message describing the meaning of the value of errno.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = " Return the system file descriptor for STREAM."]
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Faster version when locking is not required."]
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new stream connected to a pipe running the given command.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Close a stream opened by popen and return the status of its child.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the name of the controlling terminal."]
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Acquire ownership of STREAM."]
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Try to acquire ownership of STREAM but do not block if it is not\npossible."]
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Relinquish the ownership granted for STREAM."]
    pub fn funlockfile(__stream: *mut FILE);
}
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
#[doc = " Returned by `time'."]
pub type time_t = __time_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but\nhas nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[doc = " Used by other time functions."]
#[repr(C)]
#[derive(Debug)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: ::std::os::raw::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: ::std::os::raw::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: ::std::os::raw::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: ::std::os::raw::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: ::std::os::raw::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: ::std::os::raw::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: ::std::os::raw::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: ::std::os::raw::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: ::std::os::raw::c_int,
    #[doc = " Seconds east of UTC."]
    pub tm_gmtoff: ::std::os::raw::c_long,
    #[doc = " Timezone abbreviation."]
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[doc = " POSIX.1b structure for timer start values and intervals."]
#[repr(C)]
#[derive(Debug)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[doc = " We can use a simple forward declaration."]
#[repr(C)]
#[derive(Debug)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
extern "C" {
    #[doc = " Time used by the program so far (user time + system time).\nThe result / CLOCKS_PER_SECOND is program time in seconds."]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[doc = " Return the current time and put it in *TIMER if TIMER is not NULL."]
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    #[doc = " Return the difference between TIME1 and TIME0."]
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    #[doc = " Return the `time_t' representation of TP and normalize TP."]
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT.\nWrite no more than MAXSIZE characters and return the number\nof characters written, or 0 if it would exceed MAXSIZE."]
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
#[doc = " Structure for reentrant locale using functions.  This is an\n(almost) opaque type for the user level programs.  The file and\nthis data structure is not standardized.  Don't rely on it.  It can\ngo away without warning."]
#[repr(C)]
#[derive(Debug)]
pub struct __locale_struct {
    #[doc = " 13 = __LC_LAST."]
    pub __locales: [*mut __locale_data; 13usize],
    #[doc = " To increase the speed of this solution we add some special members."]
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    #[doc = " Note: LC_ALL is not a valid index into this array."]
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
#[doc = " Structure for reentrant locale using functions.  This is an\n(almost) opaque type for the user level programs.  The file and\nthis data structure is not standardized.  Don't rely on it.  It can\ngo away without warning."]
pub type __locale_t = *mut __locale_struct;
#[doc = " POSIX 2008 makes locale_t official."]
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER\nin Universal Coordinated Time (aka Greenwich Mean Time)."]
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation\nof *TIMER in the local timezone."]
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in UTC,\nusing *TP to store the result."]
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in local time,\nusing *TP to store the result."]
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Equivalent to `asctime (localtime (timer))'."]
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'."]
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Current timezone names."]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[doc = " If daylight-saving time is ever in use."]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seconds west of UTC."]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Same as above."]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[doc = " Set time conversion information from the TZ environment variable.\nIf TZ is not defined, a locale-dependent default is used."]
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Set the system time to *WHEN.\nThis call is restricted to the superuser."]
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like `mktime', but for TP represents Universal Time, not local time."]
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Another name for `mktime'."]
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Return the number of days in YEAR."]
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause execution for a number of nanoseconds.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get resolution of clock CLOCK_ID."]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current value of clock CLOCK_ID and store it in TP."]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set clock CLOCK_ID to value TP."]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " High-resolution sleep with the specified clock.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return clock ID for CPU-time clock."]
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create new per-process timer using CLOCK_ID."]
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete timer TIMERID."]
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set timer TIMERID to VALUE, returning old value in OVALUE."]
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current value of timer TIMERID and store it in VALUE."]
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get expiration overrun for timer TIMERID."]
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set TS to calendar time based in time base BASE."]
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const mgr_cmd_MGR_CMD_NONE: mgr_cmd = -1;
pub const mgr_cmd_MGR_CMD_CREATE: mgr_cmd = 0;
pub const mgr_cmd_MGR_CMD_DELETE: mgr_cmd = 1;
pub const mgr_cmd_MGR_CMD_SET: mgr_cmd = 2;
pub const mgr_cmd_MGR_CMD_UNSET: mgr_cmd = 3;
pub const mgr_cmd_MGR_CMD_LIST: mgr_cmd = 4;
pub const mgr_cmd_MGR_CMD_PRINT: mgr_cmd = 5;
pub const mgr_cmd_MGR_CMD_ACTIVE: mgr_cmd = 6;
pub const mgr_cmd_MGR_CMD_IMPORT: mgr_cmd = 7;
pub const mgr_cmd_MGR_CMD_EXPORT: mgr_cmd = 8;
pub const mgr_cmd_MGR_CMD_LAST: mgr_cmd = 9;
#[doc = " Add new MGR_CMDs before MGR_CMD_LAST"]
pub type mgr_cmd = ::std::os::raw::c_int;
pub const mgr_obj_MGR_OBJ_NONE: mgr_obj = -1;
#[doc = " Server"]
pub const mgr_obj_MGR_OBJ_SERVER: mgr_obj = 0;
#[doc = " Queue"]
pub const mgr_obj_MGR_OBJ_QUEUE: mgr_obj = 1;
#[doc = " Job"]
pub const mgr_obj_MGR_OBJ_JOB: mgr_obj = 2;
#[doc = " Vnode"]
pub const mgr_obj_MGR_OBJ_NODE: mgr_obj = 3;
#[doc = " Reservation"]
pub const mgr_obj_MGR_OBJ_RESV: mgr_obj = 4;
#[doc = " Resource"]
pub const mgr_obj_MGR_OBJ_RSC: mgr_obj = 5;
#[doc = " Scheduler"]
pub const mgr_obj_MGR_OBJ_SCHED: mgr_obj = 6;
#[doc = " Host"]
pub const mgr_obj_MGR_OBJ_HOST: mgr_obj = 7;
#[doc = " Hook"]
pub const mgr_obj_MGR_OBJ_HOOK: mgr_obj = 8;
#[doc = " PBS Hook"]
pub const mgr_obj_MGR_OBJ_PBS_HOOK: mgr_obj = 9;
#[doc = " Last entry"]
pub const mgr_obj_MGR_OBJ_LAST: mgr_obj = 10;
#[doc = " Add new MGR_OBJs before MGR_OBJ_LAST"]
pub type mgr_obj = ::std::os::raw::c_int;
#[repr(u32)]
#[doc = " the pair to this list is in module_pbs_v1.c and must be updated to reflect any changes"]
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub enum batch_op {
    SET = 0,
    UNSET = 1,
    INCR = 2,
    DECR = 3,
    EQ = 4,
    NE = 5,
    GE = 6,
    GT = 7,
    LE = 8,
    LT = 9,
    DFLT = 10,
}
#[doc = " This structure is identical to attropl so they can be used\n interchangably.  The op field is not used."]
#[repr(C)]
#[derive(Debug)]
pub struct attrl {
    pub next: *mut attrl,
    pub name: *mut ::std::os::raw::c_char,
    pub resource: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    #[doc = " not used"]
    pub op: batch_op,
}
#[test]
fn bindgen_test_layout_attrl() {
    const UNINIT: ::std::mem::MaybeUninit<attrl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attrl>(),
        40usize,
        concat!("Size of: ", stringify!(attrl))
    );
    assert_eq!(
        ::std::mem::align_of::<attrl>(),
        8usize,
        concat!("Alignment of ", stringify!(attrl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attrl),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attrl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attrl),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(attrl),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(attrl), "::", stringify!(op))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct attropl {
    pub next: *mut attropl,
    pub name: *mut ::std::os::raw::c_char,
    pub resource: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub op: batch_op,
}
#[test]
fn bindgen_test_layout_attropl() {
    const UNINIT: ::std::mem::MaybeUninit<attropl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<attropl>(),
        40usize,
        concat!("Size of: ", stringify!(attropl))
    );
    assert_eq!(
        ::std::mem::align_of::<attropl>(),
        8usize,
        concat!("Alignment of ", stringify!(attropl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attropl),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attropl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(attropl),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(attropl),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(attropl),
            "::",
            stringify!(op)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct batch_status {
    pub next: *mut batch_status,
    pub name: *mut ::std::os::raw::c_char,
    pub attribs: *mut attrl,
    pub text: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_batch_status() {
    const UNINIT: ::std::mem::MaybeUninit<batch_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<batch_status>(),
        32usize,
        concat!("Size of: ", stringify!(batch_status))
    );
    assert_eq!(
        ::std::mem::align_of::<batch_status>(),
        8usize,
        concat!("Alignment of ", stringify!(batch_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(batch_status),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(batch_status),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(batch_status),
            "::",
            stringify!(attribs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(batch_status),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " structure to hold an attribute that failed verification at ECL\n and the associated errcode and errmsg"]
#[repr(C)]
#[derive(Debug)]
pub struct ecl_attrerr {
    pub ecl_attribute: *mut attropl,
    pub ecl_errcode: ::std::os::raw::c_int,
    pub ecl_errmsg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ecl_attrerr() {
    const UNINIT: ::std::mem::MaybeUninit<ecl_attrerr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ecl_attrerr>(),
        24usize,
        concat!("Size of: ", stringify!(ecl_attrerr))
    );
    assert_eq!(
        ::std::mem::align_of::<ecl_attrerr>(),
        8usize,
        concat!("Alignment of ", stringify!(ecl_attrerr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecl_attribute) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecl_attrerr),
            "::",
            stringify!(ecl_attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecl_errcode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecl_attrerr),
            "::",
            stringify!(ecl_errcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecl_errmsg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ecl_attrerr),
            "::",
            stringify!(ecl_errmsg)
        )
    );
}
#[doc = " structure to hold a number of attributes that failed verification"]
#[repr(C)]
#[derive(Debug)]
pub struct ecl_attribute_errors {
    #[doc = " num of attributes that failed verification"]
    pub ecl_numerrors: ::std::os::raw::c_int,
    #[doc = " ecl_attrerr array of structs"]
    pub ecl_attrerr: *mut ecl_attrerr,
}
#[test]
fn bindgen_test_layout_ecl_attribute_errors() {
    const UNINIT: ::std::mem::MaybeUninit<ecl_attribute_errors> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ecl_attribute_errors>(),
        16usize,
        concat!("Size of: ", stringify!(ecl_attribute_errors))
    );
    assert_eq!(
        ::std::mem::align_of::<ecl_attribute_errors>(),
        8usize,
        concat!("Alignment of ", stringify!(ecl_attribute_errors))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecl_numerrors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecl_attribute_errors),
            "::",
            stringify!(ecl_numerrors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecl_attrerr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecl_attribute_errors),
            "::",
            stringify!(ecl_attrerr)
        )
    );
}
pub const preempt_method_PREEMPT_METHOD_LOW: preempt_method = 0;
pub const preempt_method_PREEMPT_METHOD_SUSPEND: preempt_method = 1;
pub const preempt_method_PREEMPT_METHOD_CHECKPOINT: preempt_method = 2;
pub const preempt_method_PREEMPT_METHOD_REQUEUE: preempt_method = 3;
pub const preempt_method_PREEMPT_METHOD_DELETE: preempt_method = 4;
pub const preempt_method_PREEMPT_METHOD_HIGH: preempt_method = 5;
pub type preempt_method = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct preempt_job_info {
    pub job_id: [::std::os::raw::c_char; 274usize],
    pub order: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_preempt_job_info() {
    const UNINIT: ::std::mem::MaybeUninit<preempt_job_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<preempt_job_info>(),
        280usize,
        concat!("Size of: ", stringify!(preempt_job_info))
    );
    assert_eq!(
        ::std::mem::align_of::<preempt_job_info>(),
        1usize,
        concat!("Alignment of ", stringify!(preempt_job_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).job_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(preempt_job_info),
            "::",
            stringify!(job_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
        274usize,
        concat!(
            "Offset of field: ",
            stringify!(preempt_job_info),
            "::",
            stringify!(order)
        )
    );
}
#[doc = " Resource Reservation Information"]
pub type pbs_resource_t = ::std::os::raw::c_int;
pub const resv_states_RESV_NONE: resv_states = 0;
pub const resv_states_RESV_UNCONFIRMED: resv_states = 1;
pub const resv_states_RESV_CONFIRMED: resv_states = 2;
pub const resv_states_RESV_WAIT: resv_states = 3;
pub const resv_states_RESV_TIME_TO_RUN: resv_states = 4;
pub const resv_states_RESV_RUNNING: resv_states = 5;
pub const resv_states_RESV_FINISHED: resv_states = 6;
pub const resv_states_RESV_BEING_DELETED: resv_states = 7;
pub const resv_states_RESV_DELETED: resv_states = 8;
pub const resv_states_RESV_DELETING_JOBS: resv_states = 9;
pub const resv_states_RESV_DEGRADED: resv_states = 10;
pub const resv_states_RESV_BEING_ALTERED: resv_states = 11;
pub const resv_states_RESV_IN_CONFLICT: resv_states = 12;
pub type resv_states = ::std::os::raw::c_uint;
extern "C" {
    pub fn __pbs_server_location() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_asyrunjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_alterjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_asyalterjob(
        c: ::std::os::raw::c_int,
        jobid: *mut ::std::os::raw::c_char,
        attrib: *mut attrl,
        extend: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_confirmresv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_ulong,
        arg5: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_connect(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_connect_extend(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_disconnect(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_manager(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut attropl,
        arg6: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_default() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_deljob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_geterrmsg(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_holdjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_loadconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_locjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_movejob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_msgjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_relnodesjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_orderjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_rerunjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_rlsjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_runjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_selectjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_sigjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_statfree(arg1: *mut batch_status);
}
extern "C" {
    pub fn pbs_statrsc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statjob(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_selstat(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statque(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statserver(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attrl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statsched(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attrl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_stathost(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statnode(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statvnode(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_statresv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_stathook(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attrl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut batch_status;
}
extern "C" {
    pub fn pbs_get_attributes_in_error(arg1: ::std::os::raw::c_int) -> *mut ecl_attribute_errors;
}
extern "C" {
    pub fn pbs_submit(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_submit_resv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut attropl,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_delresv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_terminate(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pbs_modify_resv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut attropl,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pbs_preempt_jobs(
        arg1: ::std::os::raw::c_int,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> *mut preempt_job_info;
}
extern "C" {
    #[doc = " IFL function pointers"]
    pub static mut pfn_pbs_asyrunjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_alterjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_asyalterjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_confirmresv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_ulong,
            arg5: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_connect: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_connect_extend: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_char,
            arg2: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_default:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
}
extern "C" {
    pub static mut pfn_pbs_deljob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_disconnect: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_geterrmsg: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_holdjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_loadconf: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_locjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_manager: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_char,
            arg5: *mut attropl,
            arg6: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_movejob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_msgjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
            arg4: *mut ::std::os::raw::c_char,
            arg5: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_orderjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_rerunjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_rlsjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_runjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_selectjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_sigjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statfree:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut batch_status)>;
}
extern "C" {
    pub static mut pfn_pbs_statrsc: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statjob: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_selstat: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statque: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statserver: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attrl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statsched: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attrl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_stathost: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statnode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statvnode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_statresv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_stathook: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut attrl,
            arg4: *mut ::std::os::raw::c_char,
        ) -> *mut batch_status,
    >;
}
extern "C" {
    pub static mut pfn_pbs_get_attributes_in_error: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *mut ecl_attribute_errors,
    >;
}
extern "C" {
    pub static mut pfn_pbs_submit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_char,
            arg5: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_submit_resv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut attropl,
            arg3: *mut ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >;
}
extern "C" {
    pub static mut pfn_pbs_delresv: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_terminate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub static mut pfn_pbs_preempt_jobs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut *mut ::std::os::raw::c_char,
        ) -> *mut preempt_job_info,
    >;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[doc = " 13 = __LC_LAST."]
#[repr(C)]
#[derive(Debug)]
pub struct __locale_data {
    pub _address: u8,
}
